<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RP2040 Boot Mode Test (Web Serial) v1.2</title>
    <style>
        :root {
            color-scheme: light dark;
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            margin: 2rem;
            line-height: 1.4;
        }

        h1 {
            font-size: 1.25rem;
            margin: 0 0 1rem;
        }

        .workflow-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 1536px) {
            .workflow-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .workflow-container {
                grid-template-columns: 1fr;
            }
        }

        .pane {
            border: 2px solid #64b5f6;
            border-radius: 0.75rem;
            padding: 1.25rem;
            background: #fafafa;
            transition: opacity 0.3s ease, border-color 0.3s ease;
        }

        .pane:disabled,
        .pane.pane-disabled {
            opacity: 0.5;
            border-color: #8882;
            pointer-events: none;
        }

        .pane.active {
            border-color: #2e7d32;
            background: #f1f8f4;
        }

        .pane h2 {
            margin: 0 0 1rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .pane-step {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .row {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .row-horizontal {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        button {
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #64b5f6;
            background: #e3f2fd;
            cursor: pointer;
            transition: background-color 160ms ease, border-color 160ms ease, color 160ms ease, opacity 160ms ease;
            font-size: 0.95rem;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Ensure feedback colors remain visible even when disabled */
        button.state-busy,
        button.state-success,
        button.state-error,
        button.state-busy:disabled,
        button.state-success:disabled,
        button.state-error:disabled {
            opacity: 1;
        }

        input,
        select {
            padding: 0.5rem;
            border-radius: 0.4rem;
            border: 1px solid #64b5f6;
            width: 100%;
            box-sizing: border-box;
        }

        .muted {
            opacity: 0.7;
            font-size: 0.9rem;
            margin-top: 0.25rem;
        }

        pre {
            background: #00000010;
            padding: 0.75rem;
            border-radius: 0.5rem;
            max-height: 40vh;
            overflow: auto;
            font-size: 0.85rem;
        }

        .badge {
            padding: 0.25rem 0.6rem;
            border-radius: 999px;
            background: #bbdefb;
            font-size: 0.85rem;
            border: 1px solid #64b5f6;
            display: inline-block;
        }

        /* Button feedback states */
        .state-busy {
            background: #ffe49c;
            border-color: #cfaa2a;
        }

        .state-success {
            background: #b7efc5;
            border-color: #2e7d32;
        }

        .state-error {
            background: #ffb3b3;
            border-color: #c62828;
        }

        /* Badge state variants */
        .badge.state-success {
            background: #b7efc5;
            border-color: #2e7d32;
        }

        .badge.state-error {
            background: #ffb3b3;
            border-color: #c62828;
        }

        .badge.state-busy {
            background: #ffe49c;
            border-color: #cfaa2a;
        }

        /* Toast notifications */
        #toasts {
            position: fixed;
            right: 1rem;
            bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 9999;
        }

        .toast {
            padding: 0.6rem 0.8rem;
            border-radius: 0.5rem;
            border: 1px solid #8884;
            background: #333;
            color: #fff;
            box-shadow: 0 2px 10px #0004;
            max-width: 60ch;
        }

        .toast.success {
            background: #2e7d32;
            border-color: #2e7d32;
        }

        .toast.error {
            background: #c62828;
            border-color: #c62828;
        }

        .toast.info {
            background: #455a64;
            border-color: #455a64;
        }

        .status-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #ccc;
        }

        .file-input-wrapper {
            position: relative;
        }

        input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <h1>RP2040 Firmware Uploader <span class="badge">v1.2</span></h1>

    <p class="muted" style="margin-bottom: 1.5rem;">
        Use Chrome or Edge (Web Serial required). Safari currently does not support Web Serial.
    </p>

    <div class="workflow-container">
        <!-- Pane 1: Connect Device -->
        <div class="pane active" id="pane-connect">
            <h2>1. Connect Device</h2>
            <p class="pane-step">Select your RP2040 device via serial port</p>

            <div class="row">
                <button id="btn-pick">Pick Device</button>
                <span id="port-info" class="badge">No device selected</span>
            </div>

            <div class="status-section">
                <div class="muted"><strong>Status:</strong> <span id="connect-status">Ready to connect</span></div>
            </div>
        </div>

        <!-- Pane 2: Start Bootloader -->
        <div class="pane pane-disabled" id="pane-bootloader">
            <h2>2. Start Bootloader</h2>
            <p class="pane-step">Reboot device into BOOTSEL mode</p>

            <div class="row">
                <button id="btn-1200" disabled>Reboot to Bootloader</button>
                <span class="muted">Serial port will disappear when successful.</span>
            </div>

            <div class="status-section">
                <div class="muted"><strong>Status:</strong> <span id="bootloader-status">Waiting for device
                        connection...</span></div>
            </div>
        </div>

        <!-- Pane 3: Pick Drive -->
        <div class="pane pane-disabled" id="pane-drive">
            <h2>3. Confirm/Pick Drive</h2>
            <p class="pane-step">After reboot, device appears as RPI-RP2 drive</p>

            <div class="row">
                <button id="btn-pick-drive" disabled>Pick RPI-RP2 Drive</button>
                <span id="drive-info" class="badge">No drive selected</span>
            </div>

            <div class="status-section">
                <div class="muted"><strong>Status:</strong> <span id="drive-status">Waiting for reboot...</span></div>
            </div>
        </div>

        <!-- Pane 4: Upload Firmware -->
        <div class="pane pane-disabled" id="pane-upload">
            <h2>4. Upload Firmware</h2>
            <p class="pane-step">Select and upload UF2 firmware file</p>

            <div class="row">
                <button id="btn-uf2">Select UF2 File</button>
                <input id="file-uf2" type="file" accept=".uf2" style="display:none" />
                <span id="uf2-info" class="badge">No file selected</span>
            </div>

            <div class="row">
                <input id="uf2-url" type="url" placeholder="Or enter UF2 URL..." />
            </div>

            <div class="row">
                <button id="btn-fetch-uf2">Fetch from URL</button>
                <span id="url-info" class="badge" style="display:none;"></span>
            </div>

            <div class="row">
                <button id="btn-write-uf2" disabled>Write UF2 to Drive</button>
                <span id="write-ready" class="badge">Not ready</span>
            </div>

            <div class="status-section">
                <div class="muted"><strong>Status:</strong> <span id="upload-status">Waiting for drive
                        selection...</span></div>
            </div>
        </div>
    </div>

    <div class="row-horizontal" style="margin-top: 1.5rem; margin-bottom: 1rem;">
        <button id="btn-clear">Clear Log</button>
    </div>

    <pre id="log" aria-live="polite"></pre>

    <div id="toasts" aria-live="polite" aria-atomic="true"></div>

    <script>
        const logEl = document.getElementById('log');
        const pickBtn = document.getElementById('btn-pick');
        const infoEl = document.getElementById('port-info');
        const touchBtn = document.getElementById('btn-1200');
        const clearBtn = document.getElementById('btn-clear');
        const pickUf2Btn = document.getElementById('btn-uf2');
        const fileUf2Input = document.getElementById('file-uf2');
        const uf2Info = document.getElementById('uf2-info');
        const uf2UrlInput = document.getElementById('uf2-url');
        const fetchUf2Btn = document.getElementById('btn-fetch-uf2');
        const urlInfo = document.getElementById('url-info');
        const pickDriveBtn = document.getElementById('btn-pick-drive');
        const driveInfo = document.getElementById('drive-info');
        const writeUf2Btn = document.getElementById('btn-write-uf2');
        const writeReady = document.getElementById('write-ready');
        const toasts = document.getElementById('toasts');

        // Pane elements
        const paneConnect = document.getElementById('pane-connect');
        const paneBootloader = document.getElementById('pane-bootloader');
        const paneDrive = document.getElementById('pane-drive');
        const paneUpload = document.getElementById('pane-upload');
        const connectStatus = document.getElementById('connect-status');
        const bootloaderStatus = document.getElementById('bootloader-status');
        const driveStatus = document.getElementById('drive-status');
        const uploadStatus = document.getElementById('upload-status');

        let selectedPort = null;
        let isOpen = false;
        let selectedDirectory = null; // RPI-RP2 directory handle
        let uf2Blob = null;           // Chosen UF2 content
        let uf2Name = '';             // Name to write on the drive
        let expectingReboot = false;  // True during/after 1200-bps touch
        let portDisconnected = false; // True when port disappeared (but not confirmed in bootloader)
        let rebootSuccessful = false;  // True when RPI-RP2 drive is verified
        let selectedPortInfo = null;  // Store port info for comparison with disconnect events

        function log(message) {
            const ts = new Date().toLocaleTimeString();
            logEl.textContent += `[${ts}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        function requireWebSerial() {
            if (!('serial' in navigator)) {
                const msg = 'Web Serial API not available. Use Chrome/Edge and enable it if needed.';
                alert(msg);
                log(msg);
                return false;
            }
            return true;
        }

        function describePort(port) {
            try {
                const info = port.getInfo?.() || {};
                const usb = [];
                if (info.usbVendorId != null) usb.push('vid=' + info.usbVendorId.toString(16));
                if (info.usbProductId != null) usb.push('pid=' + info.usbProductId.toString(16));
                return usb.length ? `USB(${usb.join(',')})` : 'Unknown interface';
            } catch {
                return 'Unknown interface';
            }
        }

        function setInfo(text) {
            infoEl.textContent = text;
        }

        function setDrive(text) {
            driveInfo.textContent = text;
        }

        function setUf2Status(text) {
            uf2Info.textContent = text;
        }

        function updateWriteReadyBadge() {
            const ready = !!(uf2Blob && selectedDirectory);
            writeReady.textContent = ready ? 'Ready' : 'Not ready';
            writeReady.classList.toggle('state-success', ready);
            writeReady.classList.toggle('state-error', !ready);
            writeUf2Btn.disabled = !ready;

            if (ready) {
                uploadStatus.textContent = 'Ready to upload';
            } else {
                uploadStatus.textContent = 'Select UF2 file' + (selectedDirectory ? '' : ' and drive');
            }
        }

        function updatePaneStates() {
            // Pane 1 (Connect) is always active
            paneConnect.classList.add('active');
            paneConnect.classList.remove('pane-disabled');

            // Pane 2 (Bootloader) becomes active when device is selected
            // Stays available (not disabled) after reboot, but only "active" when device connected
            if (selectedPort) {
                paneBootloader.classList.remove('pane-disabled');
                paneBootloader.classList.add('active');
                touchBtn.disabled = false;
            } else if (portDisconnected || rebootSuccessful) {
                // After reboot, keep pane available but not active (not green)
                paneBootloader.classList.remove('pane-disabled', 'active');
                touchBtn.disabled = true;
                // Clear button state colors so it shows as disabled but not error/success
                touchBtn.classList.remove('state-success', 'state-error', 'state-busy');
            } else {
                // Before device is selected, pane is disabled
                paneBootloader.classList.add('pane-disabled');
                paneBootloader.classList.remove('active');
                touchBtn.disabled = true;
            }

            // Pane 3 (Drive) becomes active when port disconnects (allows picking drive)
            // Success is only confirmed when RPI-RP2 drive is verified
            if (portDisconnected || rebootSuccessful) {
                paneDrive.classList.remove('pane-disabled');
                paneDrive.classList.add('active');
                pickDriveBtn.disabled = false;
                if (!rebootSuccessful) {
                    driveStatus.textContent = 'Port disconnected - verify RPI-RP2 drive appears';
                }
            } else {
                paneDrive.classList.add('pane-disabled');
                paneDrive.classList.remove('active');
                pickDriveBtn.disabled = true;
            }

            // Pane 4 (Upload) becomes active when drive is selected
            if (selectedDirectory) {
                paneUpload.classList.remove('pane-disabled');
                paneUpload.classList.add('active');
            } else {
                paneUpload.classList.add('pane-disabled');
                paneUpload.classList.remove('active');
                writeUf2Btn.disabled = true;
            }
        }

        function toast(message, type = 'info', timeoutMs = 3000) {
            try {
                const el = document.createElement('div');
                el.className = `toast ${type}`;
                el.textContent = message;
                toasts.appendChild(el);
                setTimeout(() => { el.remove(); }, timeoutMs);
            } catch { }
        }

        function explainFsWriteError(e) {
            const name = e?.name || '';
            const msg = String(e?.message || e || '');
            let hint = '';
            if (!window.isSecureContext) {
                hint += '\n- This page is not in a secure context. Use https or http://localhost.';
            }
            if (msg.toLowerCase().includes('security')) {
                hint += '\n- macOS: System Settings → Privacy & Security → Files and Folders → allow Chrome/Edge access to Removable Volumes.';
                hint += '\n- Windows: If Controlled folder access is on, allow Chrome/Edge or turn it off temporarily.';
            }
            if (!window.showDirectoryPicker) {
                hint += '\n- Your browser does not support the File System Access API (use Chrome/Edge).';
            }
            return `${name}: ${msg}${hint ? '\n\nHints:' + hint : ''}`;
        }

        async function pickDevice() {
            if (!requireWebSerial()) return;
            try {
                // Reset all state when picking a new device
                portDisconnected = false;
                rebootSuccessful = false;
                expectingReboot = false;
                selectedDirectory = null;
                uf2Blob = null;
                uf2Name = '';
                selectedPort = null; // Clear port so panes reset properly

                // Reset pane states immediately
                paneBootloader.classList.add('pane-disabled');
                paneBootloader.classList.remove('active');
                paneDrive.classList.add('pane-disabled');
                paneDrive.classList.remove('active');
                paneUpload.classList.add('pane-disabled');
                paneUpload.classList.remove('active');

                // Reset button states
                touchBtn.classList.remove('state-busy', 'state-success', 'state-error');
                touchBtn.disabled = true;
                pickDriveBtn.classList.remove('state-busy', 'state-success', 'state-error');
                writeUf2Btn.classList.remove('state-busy', 'state-success', 'state-error');

                // Reset info badges
                infoEl.classList.remove('state-success', 'state-error');
                driveInfo.classList.remove('state-success', 'state-error');
                uf2Info.classList.remove('state-success', 'state-error');
                writeReady.classList.remove('state-success', 'state-error');

                // Visual feedback while the browser device picker is open
                pickBtn.classList.remove('state-success', 'state-error');
                pickBtn.classList.add('state-busy');
                infoEl.classList.add('state-busy');
                connectStatus.textContent = 'Selecting device...';
                bootloaderStatus.textContent = 'Waiting for device connection...';
                driveStatus.textContent = 'Waiting for reboot...';
                uploadStatus.textContent = 'Waiting for drive selection...';

                // Reset info text
                setInfo('Selecting...');
                setDrive('No drive selected');
                setUf2Status('No file selected');
                writeReady.textContent = 'Not ready';

                const port = await navigator.serial.requestPort();
                selectedPort = port;
                try {
                    selectedPortInfo = port.getInfo?.() || {};
                } catch {
                    selectedPortInfo = {};
                }
                setInfo(describePort(port));
                log('Device selected: ' + describePort(port));

                // Success feedback
                pickBtn.classList.remove('state-busy');
                pickBtn.classList.add('state-success');
                infoEl.classList.remove('state-busy');
                infoEl.classList.add('state-success');
                connectStatus.textContent = 'Device connected';
                bootloaderStatus.textContent = 'Ready to reboot';

                // Update pane states to default
                updatePaneStates();
                updateWriteReadyBadge();
            } catch (e) {
                log('Device selection cancelled or failed.');
                console.error(e);
                // Error/cancel feedback
                pickBtn.classList.remove('state-busy', 'state-success');
                pickBtn.classList.add('state-error');
                infoEl.classList.remove('state-busy', 'state-success');
                connectStatus.textContent = 'Selection cancelled';
            }
        }

        async function ensureClosed() {
            try {
                if (selectedPort && isOpen) {
                    await selectedPort.close();
                    isOpen = false;
                    log('Port closed.');
                }
            } catch (e) {
                console.warn('ensureClosed error', e);
            }
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function isLikelyRebootError(e) {
            const text = String(e?.message || e || '').toLowerCase();
            // Common messages when the device resets while the port is open/closing
            return text.includes('device has been lost')
                || text.includes('was disconnected')
                || text.includes('transfer error')
                || text.includes('pipe error')
                || text.includes('operation timed out');
        }

        async function do1200BpsTouch() {
            // Visual feedback immediately, even during device selection
            touchBtn.classList.remove('state-success', 'state-error');
            touchBtn.classList.add('state-busy');
            bootloaderStatus.textContent = 'Rebooting to bootloader...';

            if (!selectedPort) {
                // Also show busy state on the Pick Device button to hint at selection
                pickBtn.classList.remove('state-success', 'state-error');
                pickBtn.classList.add('state-busy');
                await pickDevice();
                pickBtn.classList.remove('state-busy');
                if (!selectedPort) {
                    touchBtn.classList.remove('state-busy');
                    bootloaderStatus.textContent = 'No device selected';
                    return;
                }
            }
            await ensureClosed();
            expectingReboot = true;
            try {
                log('Opening at 1200 bps...');
                await selectedPort.open({ baudRate: 1200 });
                isOpen = true;

                // Some implementations watch DTR/RTS transitions
                // Try to toggle signals, but don't fail if it's not supported or errors
                if (selectedPort.setSignals) {
                    try {
                        await selectedPort.setSignals({ dataTerminalReady: false, requestToSend: false });
                        await sleep(20);
                        await selectedPort.setSignals({ dataTerminalReady: true, requestToSend: false });
                        await sleep(20);
                        await selectedPort.setSignals({ dataTerminalReady: false, requestToSend: false });
                    } catch (sigErr) {
                        // setSignals may fail on some systems, but the 1200-bps touch itself may still work
                        log('Note: Signal toggle failed (device may still reboot): ' + (sigErr?.message || sigErr));
                    }
                }

                // Close promptly; device should reset if it supports the 1200-bps touch
                await selectedPort.close();
                isOpen = false;

                // Give the device a moment to reboot and disappear (increased wait for disconnect event)
                await sleep(500);

                // Check if port was already marked as disconnected by the event handler
                if (portDisconnected) {
                    // Disconnect event already handled it - nothing to do here
                    touchBtn.classList.remove('state-busy');
                    touchBtn.classList.add('state-success');
                    log('Port disconnect confirmed by event handler. Please verify RPI-RP2 drive appears.');
                } else {
                    // Check if the port is still available - if it disappeared, reboot was successful
                    let portStillExists = false;
                    try {
                        // Try to access port info - if port disappeared, this might fail or the port object becomes invalid
                        if (selectedPort) {
                            selectedPort.getInfo();
                            portStillExists = true;
                        }
                    } catch {
                        portStillExists = false;
                    }

                    if (!portStillExists || !selectedPort) {
                        // Port disappeared - this is a good sign, but not confirmation
                        log('Serial port disappeared. Please verify RPI-RP2 drive appears before confirming reboot success.');
                        toast('Port disconnected. Please pick RPI-RP2 drive to verify bootloader mode.', 'info');
                        selectedPort = null;
                        selectedPortInfo = null;
                        setInfo('Port disconnected - verify drive');
                        touchBtn.classList.remove('state-busy');
                        touchBtn.classList.add('state-success');
                        bootloaderStatus.textContent = 'Reboot successful - port disconnected';
                        portDisconnected = true;
                        rebootSuccessful = false; // Not confirmed until drive is picked
                        updatePaneStates();
                    } else {
                        log('Closed after 1200-bps touch. Serial port still present - device may not have rebooted to bootloader.');
                        toast('Port still present. Device may not be in bootloader mode.', 'error');
                        touchBtn.classList.remove('state-busy');
                        touchBtn.classList.add('state-error');
                        bootloaderStatus.textContent = 'Port still present - reboot may have failed';
                        portDisconnected = false;
                        rebootSuccessful = false;
                        updatePaneStates();
                    }
                }
            } catch (e) {
                console.error(e);
                if (isLikelyRebootError(e)) {
                    // Port disconnected during operation - good sign, but verify drive
                    isOpen = false;
                    log('Serial port disappeared during 1200-bps touch. Please verify RPI-RP2 drive appears to confirm bootloader mode.');
                    toast('Port disconnected. Please pick RPI-RP2 drive to verify bootloader mode.', 'info');
                    selectedPort = null;
                    selectedPortInfo = null;
                    setInfo('Port disconnected - verify drive');
                    touchBtn.classList.remove('state-busy');
                    touchBtn.classList.add('state-success');
                    bootloaderStatus.textContent = 'Reboot successful - port disconnected';
                    portDisconnected = true;
                    rebootSuccessful = false; // Not confirmed until drive is picked
                    updatePaneStates();
                } else {
                    log('1200-bps touch failed: ' + (e?.message || e));
                    toast('Failed to open at 1200 bps or toggle signals.', 'error');
                    touchBtn.classList.remove('state-busy');
                    touchBtn.classList.add('state-error');
                    bootloaderStatus.textContent = 'Reboot failed';
                    portDisconnected = false;
                    rebootSuccessful = false;
                }
            } finally {
                expectingReboot = false;
            }
        }

        pickBtn.addEventListener('click', pickDevice);
        touchBtn.addEventListener('click', do1200BpsTouch);
        clearBtn.addEventListener('click', () => { logEl.textContent = ''; });

        // ===== UF2 programming helpers =====
        async function pickUf2File() {
            try {
                if (window.showOpenFilePicker) {
                    const [handle] = await window.showOpenFilePicker({
                        multiple: false,
                        types: [{ description: 'UF2 firmware', accept: { 'application/octet-stream': ['.uf2'] } }]
                    });
                    const file = await handle.getFile();
                    uf2Blob = file;
                    uf2Name = file.name || 'firmware.uf2';
                    setUf2Status(uf2Name + ' (' + file.size + ' bytes)');
                    uf2Info.classList.add('state-success');
                    uf2Info.classList.remove('state-error');
                    log('UF2 selected: ' + uf2Name);
                } else {
                    fileUf2Input.click();
                }
            } catch (e) {
                log('UF2 selection cancelled.');
            }
            updateWriteReadyBadge();
        }

        pickUf2Btn.addEventListener('click', pickUf2File);
        fileUf2Input.addEventListener('change', async (ev) => {
            const file = ev.target.files?.[0];
            if (file) {
                uf2Blob = file;
                uf2Name = file.name || 'firmware.uf2';
                setUf2Status(uf2Name + ' (' + file.size + ' bytes)');
                uf2Info.classList.add('state-success');
                uf2Info.classList.remove('state-error');
                log('UF2 selected: ' + uf2Name);
            }
            updateWriteReadyBadge();
        });

        async function fetchUf2FromUrl() {
            const url = (uf2UrlInput.value || '').trim();
            if (!url) { alert('Enter a UF2 URL first.'); return; }
            try {
                urlInfo.textContent = 'Fetching…';
                urlInfo.style.display = 'inline-block';
                uploadStatus.textContent = 'Fetching firmware...';
                const res = await fetch(url, { cache: 'no-cache' });
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const blob = await res.blob();
                uf2Blob = blob;
                try { uf2Name = new URL(url).pathname.split('/').pop() || 'firmware.uf2'; } catch { uf2Name = 'firmware.uf2'; }
                setUf2Status(uf2Name + ' (' + blob.size + ' bytes)');
                uf2Info.classList.add('state-success');
                uf2Info.classList.remove('state-error');
                urlInfo.textContent = 'Fetched';
                urlInfo.classList.add('state-success');
                log('UF2 fetched from URL: ' + uf2Name);
            } catch (e) {
                console.error(e);
                urlInfo.textContent = 'Fetch failed';
                urlInfo.classList.remove('state-success');
                urlInfo.classList.add('state-error');
                toast('Failed to fetch UF2: ' + (e?.message || e), 'error');
                uf2Info.classList.remove('state-success');
                uf2Info.classList.add('state-error');
            }
            updateWriteReadyBadge();
        }
        fetchUf2Btn.addEventListener('click', fetchUf2FromUrl);

        async function pickDrive() {
            if (!window.showDirectoryPicker) { toast('Your browser does not support the File System Access API (use Chrome/Edge).', 'error'); return; }
            try {
                pickDriveBtn.classList.remove('state-success', 'state-error');
                pickDriveBtn.classList.add('state-busy');
                driveStatus.textContent = 'Selecting drive...';
                const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
                selectedDirectory = dir;
                setDrive('Picked');
                log('Drive picked. Checking for UF2 markers');
                let likely = false;
                try { await dir.getFileHandle('INFO_UF2.TXT'); likely = true; } catch { }
                try { await dir.getFileHandle('INDEX.HTM'); likely = true; } catch { }
                if (likely) {
                    setDrive('RPI-RP2 (verified)');
                    driveInfo.classList.add('state-success');
                    driveInfo.classList.remove('state-error');
                    log('UF2 markers found: this looks like the RPI-RP2 drive.');
                    driveStatus.textContent = 'Drive verified - RPI-RP2 detected';
                    toast('RPI-RP2 drive selected and verified. Reboot to bootloader confirmed!', 'success');
                    // NOW we can confirm reboot was successful
                    rebootSuccessful = true;
                    bootloaderStatus.textContent = 'Reboot confirmed - RPI-RP2 verified';
                    touchBtn.classList.add('state-success');
                } else {
                    setDrive('Picked (unverified)');
                    driveInfo.classList.remove('state-success');
                    driveInfo.classList.add('state-error');
                    log('UF2 markers not found. Ensure you selected the root of the RPI-RP2 drive.');
                    driveStatus.textContent = 'Drive picked but not verified';
                    toast('Warning: Selected drive does not appear to be RPI-RP2. Reboot may not have succeeded.', 'error');
                    rebootSuccessful = false;
                    bootloaderStatus.textContent = 'Drive not verified - reboot may have failed';
                }
                pickDriveBtn.classList.remove('state-busy');
                pickDriveBtn.classList.add('state-success');
            } catch (e) {
                log('Drive selection cancelled.');
                pickDriveBtn.classList.remove('state-busy');
                driveStatus.textContent = 'Selection cancelled';
            }
            updatePaneStates();
            updateWriteReadyBadge();
        }
        pickDriveBtn.addEventListener('click', pickDrive);

        async function writeUf2ToDrive() {
            if (!selectedDirectory || !uf2Blob) { alert('Pick a UF2 and the drive first.'); return; }
            try {
                writeUf2Btn.disabled = true;
                writeUf2Btn.classList.remove('state-success', 'state-error');
                writeUf2Btn.classList.add('state-busy');
                uploadStatus.textContent = 'Writing firmware...';
                const fileHandle = await selectedDirectory.getFileHandle(uf2Name || 'firmware.uf2', { create: true });
                const writable = await fileHandle.createWritable();
                const buf = await uf2Blob.arrayBuffer();
                log('Writing ' + (buf.byteLength || 0) + ' bytes to ' + (uf2Name || 'firmware.uf2') + '...');
                await writable.write(buf);
                await writable.close();
                log('Write complete. Device should reboot and the drive may disappear.');
                toast('UF2 written. The device should reboot now.', 'success');
                uploadStatus.textContent = 'Firmware uploaded successfully!';
                writeUf2Btn.classList.remove('state-busy');
                writeUf2Btn.classList.add('state-success');
            } catch (e) {
                console.error(e);
                toast('Failed to write UF2: ' + explainFsWriteError(e), 'error');
                uploadStatus.textContent = 'Upload failed';
                writeUf2Btn.classList.remove('state-busy');
                writeUf2Btn.classList.add('state-error');
            } finally {
                updateWriteReadyBadge();
            }
        }
        writeUf2Btn.addEventListener('click', writeUf2ToDrive);

        // Initial capability check
        if (!('serial' in navigator)) {
            setInfo('Web Serial not available');
            log('Web Serial not available. Use Chrome/Edge.');
            connectStatus.textContent = 'Web Serial not available';
        }

        // Log connect/disconnect to make reboot behavior clearer
        if ('serial' in navigator) {
            navigator.serial.addEventListener('connect', (e) => {
                try { log('Serial device connected: ' + describePort(e.port)); } catch { log('Serial device connected.'); }
            });
            navigator.serial.addEventListener('disconnect', (e) => {
                // If we're expecting a reboot, ANY disconnect is likely our device rebooting
                if (expectingReboot) {
                    log('Serial port disappeared during reboot. Please pick RPI-RP2 drive to verify bootloader mode.');
                    toast('Port disconnected. Please pick RPI-RP2 drive to verify bootloader mode.', 'info');
                    selectedPort = null;
                    selectedPortInfo = null;
                    isOpen = false;
                    setInfo('Port disconnected - verify drive');
                    touchBtn.classList.remove('state-busy', 'state-error');
                    touchBtn.classList.add('state-success');
                    bootloaderStatus.textContent = 'Reboot successful - port disconnected';
                    expectingReboot = false;
                    portDisconnected = true;
                    rebootSuccessful = false; // Not confirmed until drive is picked
                    updatePaneStates();
                } else if (selectedPort && e.port === selectedPort) {
                    log('Selected device disconnected (likely reboot).');
                } else {
                    try { log('Serial device disconnected: ' + describePort(e.port)); } catch { log('Serial device disconnected.'); }
                }
            });
        }

        // File System Access capability notes
        if (!window.isSecureContext) {
            log('Warning: Not a secure context. File System Access may be limited. Use https or http://localhost.');
        }
        if (!window.showDirectoryPicker) {
            log('File System Access API not available. UF2 writing requires Chrome/Edge.');
        }

        // Initial pane states
        updatePaneStates();
        updateWriteReadyBadge();
    </script>
</body>

</html>